package postactionresponsewriter

import (
	json2 "encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"time"

	"github.com/http-everything/httpe/pkg/actions"
	"github.com/http-everything/httpe/pkg/config"
	"github.com/http-everything/httpe/pkg/share/logger"
	gonanoid "github.com/matoous/go-nanoid/v2"
)

const FilePrefix = "httpe-postrun"

type PostActionResponseWriter struct {
	responses []PostActionResponse
	dataDir   string
	logger    *logger.Logger
	retention string
}

type PostActionResponse struct {
	ActionType string `json:"action_type"`
	actions.ActionResponse
	InternalError string `json:"internal_error"`
}

func New(conf *config.Config, logger2 *logger.Logger) PostActionResponseWriter {
	return PostActionResponseWriter{
		responses: make([]PostActionResponse, 0),
		logger:    logger2,
		dataDir:   conf.S.DataDir,
		retention: conf.S.DataRetention,
	}
}

func (p *PostActionResponseWriter) AddActionResponse(t string, actionResponse actions.ActionResponse, err error) {
	p.responses = append(p.responses, PostActionResponse{
		ActionResponse: actionResponse,
		InternalError:  e2s(err),
		ActionType:     t,
	})
}

func (p *PostActionResponseWriter) Write() {
	fileName := p.fileName()
	if fileName == "" {
		return
	}
	file, err := os.Create(fileName)
	if err != nil {
		p.logger.Errorf("Failed to create file %s: %v", fileName, err)
	}
	defer func() {
		if err := file.Close(); err != nil {
			p.logger.Errorf("Failed to close file %s: %v", fileName, err)
		}
	}()

	encoder := json2.NewEncoder(file)
	encoder.SetIndent("", "  ") // Optional: to pretty-print JSON
	err = encoder.Encode(p.responses)
	if err != nil {
		p.logger.Errorf("Failed to write action response: %v", err)
	}
	p.logger.Debugf("Writing action response to file %s", fileName)

	deleted, err := p.dataDirCleanup()
	if err != nil {
		p.logger.Errorf("Failed to cleanup data directory %s: %v", p.dataDir, err)
	}
	p.logger.Debugf("Deleted %d files from data directory", deleted)
}

func (p *PostActionResponseWriter) fileName() (fileName string) {
	uid, err := gonanoid.Generate("abcdefghijklmnpqrstuvw", 6)
	if err != nil {
		p.logger.Errorf("Error generating uid for post action response writing: %s", err)
	}
	fileName = fmt.Sprintf("%s-%s-%x.json", FilePrefix, time.Now().Format("2006-01-02-15-04-05"), uid)
	return filepath.Join(p.dataDir, fileName)
}

func (p *PostActionResponseWriter) dataDirCleanup() (int, error) {
	retention, err := time.ParseDuration(p.retention)
	if err != nil {
		return 0, err
	}
	// Construct regex pattern to match file names generated by fileName() function
	pattern := `^` + FilePrefix + `-\d{4}-\d{2}-\d{2}-\d{2}-\d{2}-\d{2}-[a-z0-9]{12}\.json$`
	re, err := regexp.Compile(pattern)
	if err != nil {
		return 0, fmt.Errorf("failed to compile regex: %w", err)
	}

	// Get the current time
	now := time.Now()
	deletedFilesCount := 0

	// Open the directory
	dirEntries, err := os.ReadDir(p.dataDir)
	if err != nil {
		return 0, fmt.Errorf("failed to read directory: %w", err)
	}

	// Iterate over each entry in the directory
	for _, entry := range dirEntries {
		if entry.IsDir() {
			continue // Skip directories
		}

		// Get the full path of the file
		filePath := filepath.Join(p.dataDir, entry.Name())

		// Check if the file name matches the regex
		if !re.MatchString(entry.Name()) {
			continue
		}

		// Get file info to check its modification time
		info, err := entry.Info()
		if err != nil {
			return 0, fmt.Errorf("failed to get file info for %s: %w", filePath, err)
		}

		// Check if the file is older than the retention duration
		if now.Sub(info.ModTime()) > retention {
			// Delete the file
			err := os.Remove(filePath)
			if err != nil {
				return 0, fmt.Errorf("failed to delete file %s: %w", filePath, err)
			}
			deletedFilesCount++
		}
	}

	return deletedFilesCount, nil
}

func e2s(err error) string {
	if err != nil {
		return err.Error()
	}
	return ""
}
